'From Croquet1.0beta of 11 April 2006 [latest update: #0] on 11 April 2006 at 3:06:34 pm'!Smalltalk condenseSources!----QUIT----#(11 April 2006 3:07:10 pm) Homebase.image priorSource: 0!----STARTUP----#(13 November 2006 11:00:44 am) as C:\CroquetSDK-1.0\deployment\Homebase.image!----SNAPSHOT----#(13 November 2006 11:00:51 am) Rebuilt.image priorSource: 119!----STARTUP----#(13 November 2006 11:01:08 am) as C:\CroquetSDK-1.0\Rebuilt.image!!MCDependencySorter methodsFor: 'sorting' stamp: 'ar 9/9/2006 19:57' prior: 24994000!orderedItems	"Ensure total ordering of orderedItems by resorting them"	^orderedItems asArray sort asOrderedCollection! !!MCPatch methodsFor: 'applying' stamp: 'ar 9/9/2006 17:31' prior: 25135025!applyTo: anObject	operations asSortedCollection do: [:ea | ea applyTo: anObject].! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2006 11:54' prior: 25065406!getConflictMenu: aMenu	selection remoteChosen		ifTrue: [aMenu add: 'undo keep remote' target: self selector: #clearChoice]		ifFalse: [aMenu add: 'keep remote' target: self selector: #chooseRemote].	selection localChosen		ifTrue: [aMenu add: 'undo keep local' target: self selector: #clearChoice]			ifFalse: [aMenu add: 'keep local' target: self selector: #chooseLocal].	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2006 11:54' prior: 25066235!innerButtonRow	^ self buttonRow:		#(('Keep Local' chooseLocal 'Keep the local version' selectionIsConflicted)		('Keep Remote' chooseRemote 'Keep the remote version' selectionIsConflicted))! !"Monticello"!!SharedQueue methodsFor: 'private' stamp: 'ar 6/19/2006 11:40' prior: 30961493!makeRoomAtEnd	| contentsSize |	readPosition = 1		ifTrue: [contentsArray := contentsArray , (Array new: 10)]		ifFalse: 			[contentsSize := writePosition - readPosition.			"BLT direction ok for this. Lots faster!!!!!!!!!!!! SqR!!!! 4/10/2000 10:47"			contentsArray				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition.			"fix: clear the old upper range so we don't hoard references."			contentsArray				from: contentsSize+1 "new end of content"				to: writePosition-1 "old write position"				put: nil.			readPosition := 1.			writePosition := contentsSize + 1]! !!SharedQueue methodsFor: 'private' stamp: 'ar 10/4/2006 12:43'!printOn: aStream	super printOn: aStream.	"Print a guesstimate of the size of the queue without aquiring the lock properly"	aStream nextPut: $(.	aStream print: writePosition - readPosition.	aStream nextPut: $).! !"Collections"!!Encoder commentStamp: '<historical>' prior: 20787323!I encode names and literals into tree nodes with byte codes for the compiler. Byte codes for literals are not assigned until the tree-sizing pass of the compiler, because only then is it known which literals are actually needed. I also keep track of sourceCode ranges during parsing and code generation so I can provide an inverse map for the debugger.!!Encoder methodsFor: 'temps' stamp: 'ar 9/9/2006 12:05' prior: 20792585!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node := scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self warnAboutShadowed: name].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'ar 9/9/2006 12:06' prior: 20794440!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp)			ifTrue:[^self notify:'Name is already defined']			ifFalse:[self warnAboutShadowed: name]].	^self reallyBind: name! !!Encoder methodsFor: 'accessing' stamp: 'ar 9/9/2006 12:06'!selector	^selector! !!Encoder methodsFor: 'accessing' stamp: 'ar 9/9/2006 12:06'!selector: aSymbol	selector := aSymbol! !!Encoder methodsFor: 'private' stamp: 'ar 9/9/2006 12:13'!warnAboutShadowed: name	Transcript cr; show: class name,'>>', selector, '(', name,' is shadowed)'! !!Parser methodsFor: 'expression types' stamp: 'ar 9/9/2006 12:13' prior: 28020167!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode args |	properties := MethodProperties new.	encoder := encoderToUse.	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	properties selector: (sap at: 1).	encoder selector: (sap at: 1).	"The following is a tricky conversion to bind the args here instead of in #pattern:inContext:"	args := sap at: 2.	args := args collect:[:argNode|		argNode isString 			ifTrue:[(encoder bindArg: argNode) isArg: true; yourself]			ifFalse:[argNode isArg: true; yourself]].	sap at: 2 put: args.	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse:[self properties].	prim := 0.	properties ifNotNil:[		prim := properties at: #primitiveIndex ifAbsent:[0].		"don't preserve primitive index"		properties removeKey: #primitiveIndex ifAbsent:[].	].	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode := self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!Parser methodsFor: 'expression types' stamp: 'ar 9/9/2006 12:14' prior: 28021526!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector |	doitFlag := fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector := self advance asSymbol.			args := Array with: self argumentName.			^ {selector. args. 2}].	hereType == #keyword		ifTrue: 			[selector := WriteStream on: (String new: 32).			args := OrderedCollection new.			[hereType == #keyword] whileTrue:[				selector nextPutAll: self advance.				args addLast: self argumentName.			].			^ {selector contents asSymbol. args. 3}].	hereType == #positionalMessage ifTrue:[		args := OrderedCollection new.		selector := self advance.		hereType == #rightParenthesis ifTrue:[self advance. ^{(selector,'/0') asSymbol. args. 1}].		[			args addLast: self argumentName.			hereType == #rightParenthesis ifTrue:[				self advance. 				selector := (selector,'/', args size printString) asSymbol.				^{selector. args. 1}].			here == #, ifFalse:[self expected: 'comma'].			self advance.		] repeat.	].	^ self expected: 'Message pattern'! !"Compiler"!!Float class methodsFor: 'constants' stamp: 'ar 5/24/2006 14:14'!epsilon	^Epsilon! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:44' prior: 22024826!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveArcTan' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'arcTan is undefined for NaN'].	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	^self primitiveArcTan! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:50' prior: 22025970!cos	"Answer the cosine of the receiver taken as an angle in radians."	<primitive: 'primitiveCos' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'cos is undefined for NaN'].	self abs = Float infinity ifTrue:[^self error: 'cos is undefined for Infinity'].	^ (self + Halfpi) sin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:45' prior: 22026734!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	<primitive: 'primitiveExp' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'exp is undefined for NaN'].	"For now, fall back to the Squeak version of exp if FloatMathPlugin is absent"	^self primitiveExp! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:50' prior: 22029478!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveSin' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'sin is undefined for NaN'].	self abs = Float infinity ifTrue:[^self error: 'sin is undefined for Infinity'].	^self primitiveSin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:47' prior: 22030399!tan	"Answer the tangent of the receiver taken as an angle in radians."	<primitive: 'primitiveTan' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'tan is undefined for NaN'].	^ self sin / self cos! !"Kernel"!!HandMorph methodsFor: 'private events' stamp: 'ar 7/12/2006 17:05' prior: 22736333!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type pressType stamp char |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	modifiers := evtBuf fifth.	buttons := (modifiers bitShift: 3) bitOr: (lastMouseEvent buttons bitAnd: 7).	char := self keyboardInterpreter nextCharFrom: Sensor firstEvt: evtBuf.	^ KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: char asciiValue		hand: self		stamp: stamp.! !!WorldState methodsFor: 'stepping' stamp: 'ar 6/19/2006 11:39' prior: 52233293!runStepMethodsIn: aWorld	"Perform periodic activity inbetween event cycles"	| queue msg |	queue := self class deferredUIMessages.	[(msg := queue nextOrNil) == nil] whileFalse: [		msg value.	].	self runLocalStepMethodsIn: aWorld.	"we are using a normal #step for these now"	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."! !"Morphic"!!MPEGFile class methodsFor: 'instance creation' stamp: 'bgf 11/1/2006 17:14' prior: 26704231!openFileUseBuffer: aPath 	| file bytes |	file := StandardFileStream readOnlyFileNamed: aPath.	file binary.	bytes := file contents.	file close.	^self new openBuffer: bytes path: aPath! !!MPEGFile methodsFor: 'initialize-release' stamp: 'bgf 5/12/2006 16:10'!openBuffer: aByteArray path: aPath	pathToFile := aPath.	buffer := aByteArray.	fileBits := self primFileOpenABuffer: aByteArray size: aByteArray size.	fileBits notNil ifTrue: 		[fileIndex := Smalltalk registerExternalObject: fileBits.		self register.]	! !"Movies"!!TTCFont commentStamp: 'nk 4/2/2004 11:32' prior: 50993555!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- Nominal Em size in points. Conversion to pixel sizes depends on the definition of TextStyle class>>pixelsPerInch. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray of <Color -> <Array(256) of glyph>> derivatives		Array -- stores the fonts in the same family but different emphasis.!!TTCFont class methodsFor: 'class initialization' stamp: 'ar 4/16/2006 22:17' prior: 51011328!initialize"	self initialize"	| tt |	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 8/17/2005 09:44' prior: 51011666!shutDown	"Flush the glyph cache"	GlyphCacheData atAllPut: nil.	GlyphCacheIndex := 0.! !!TTCFont methodsFor: 'private' stamp: 'ar 4/16/2006 22:18' prior: 51005584!at: char put: form	| assoc |	GlyphCacheReady == nil ifTrue:[^nil]. "during fileIn"	assoc := foregroundColor -> form.	GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: assoc.	self cache at: (char asInteger + 1) put: assoc.! !!TTCFont methodsFor: 'friend' stamp: 'ar 4/16/2006 22:18' prior: 50999490!cache	GlyphCacheReady == nil ifTrue:[^Array new: 256]. "during fileIn"	cache size = 256 ifFalse:[self recreateCache]. "old weak-array caching"	^cache! !!TTCFont methodsFor: 'friend' stamp: 'ar 8/17/2005 09:35' prior: 51001758!flushCache	cache atAllPut: nil.! !!TTCFont methodsFor: 'friend' stamp: 'ar 8/17/2005 09:35' prior: 51002381!recreateCache	cache := WeakArray new: 256.! !"Multilingual"!Socket removeSelector: #primSocketSetReusable:!Socket removeSelector: #beReusable!"Network"!!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:33' prior: 22091272!primitiveArcCos	"Computes acos(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_acos(rcvr)' inSmalltalk: [rcvr arcCos].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:33' prior: 22091765!primitiveArcCosH	"Computes acosh(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_acosh(rcvr)' inSmalltalk: [rcvr arcCosH].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:33' prior: 22092262!primitiveArcSin	"Computes asin(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_asin(rcvr)' inSmalltalk: [rcvr arcSin].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:31' prior: 22092755!primitiveArcSinH	"Computes asinh(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_asinh(rcvr)' inSmalltalk: [rcvr arcSinH].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:31' prior: 22093252!primitiveArcTan	"Computes atan(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_atan(rcvr)' inSmalltalk: [rcvr arcTan].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:31' prior: 22093745!primitiveArcTan2	"Computes atan2(receiver, arg)"	| rcvr arg result |	self export: true.	self var: #rcvr type: 'double'.	self var: #arg type: 'double'.	self var: #result type: 'double'.	arg := interpreterProxy stackFloatValue: 0.	rcvr := interpreterProxy stackFloatValue: 1.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_atan2(rcvr, arg)' inSmalltalk: [rcvr arcTan: arg].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:31' prior: 22094337!primitiveArcTanH	"Computes atanh(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_atanh(rcvr)' inSmalltalk: [rcvr arcTanH].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22094834!primitiveCos	"Computes cos(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_cos(rcvr)' inSmalltalk: [rcvr cos].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22095319!primitiveCosH	"Computes cosh(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_cosh(rcvr)' inSmalltalk: [rcvr cosH].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22095808!primitiveExp	"Computes E raised to the receiver power."	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := (self cCode: '__ieee754_exp(rcvr)' inSmalltalk: [rcvr exp]).	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22096313!primitiveFMod	"Computes receiver \\ arg"	| rcvr arg result |	self export: true.	self var: #rcvr type: 'double'.	self var: #arg type: 'double'.	self var: #result type: 'double'.	arg := interpreterProxy stackFloatValue: 0.	rcvr := interpreterProxy stackFloatValue: 1.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_fmod(rcvr, arg)' inSmalltalk: [rcvr \\ arg].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 22:51' prior: 22096891!primitiveFractionalPart	"Computes receiver \\ 1.0"	| rcvr result trunc |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	self var: #trunc type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_modf(rcvr, &trunc)' inSmalltalk: [rcvr fractionPart].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22097446!primitiveHypot	"hypot(x,y) returns sqrt(x^2+y^2) with error less  than 1 ulps"	| rcvr arg result |	self export: true.	self var: #rcvr type: 'double'.	self var: #arg type: 'double'.	self var: #result type: 'double'.	arg := interpreterProxy stackFloatValue: 0.	rcvr := interpreterProxy stackFloatValue: 1.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_hypot(rcvr, arg)' inSmalltalk: [rcvr hypot: arg].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22098067!primitiveLog10	"Computes log10(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	rcvr < 0.0 ifTrue:[^interpreterProxy primitiveFail].	result := self cCode: '__ieee754_log10(rcvr)' inSmalltalk: [rcvr log: 10].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22098616!primitiveLogN	"Computes log(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	rcvr < 0.0 ifTrue:[^interpreterProxy primitiveFail].	result := self cCode: '__ieee754_log(rcvr)' inSmalltalk: [rcvr ln].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22099155!primitiveRaisedToPower	"Computes receiver**arg"	| rcvr arg result |	self export: true.	self var: #rcvr type: 'double'.	self var: #arg type: 'double'.	self var: #result type: 'double'.	arg := interpreterProxy stackFloatValue: 0.	rcvr := interpreterProxy stackFloatValue: 1.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_pow(rcvr, arg)' inSmalltalk: [rcvr raisedTo: arg].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22099746!primitiveSin	"Computes sin(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_sin(rcvr)' inSmalltalk: [rcvr sin].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:32' prior: 22100231!primitiveSinH	"Computes sinh(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_sinh(rcvr)' inSmalltalk: [rcvr sinH].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:33' prior: 22100720!primitiveSqrt	"Computes sqrt(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	rcvr < 0.0 ifTrue:[^interpreterProxy primitiveFail].	result := self cCode: '__ieee754_sqrt(rcvr)' inSmalltalk: [rcvr sqrt].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:33' prior: 22101263!primitiveTan	"Computes tan(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_tan(rcvr)' inSmalltalk: [rcvr tan].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:33' prior: 22101748!primitiveTanH	"Computes tanh(receiver)"	| rcvr result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	rcvr := interpreterProxy stackFloatValue: 0.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_tanh(rcvr)' inSmalltalk: [rcvr tanH].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!FloatMathPlugin methodsFor: 'float primitives' stamp: 'ar 4/17/2006 21:33' prior: 22102237!primitiveTimesTwoPower	"Computes E raised to the receiver power."	| rcvr arg result |	self export: true.	self var: #rcvr type: 'double'.	self var: #result type: 'double'.	arg := interpreterProxy stackIntegerValue: 0.	rcvr := interpreterProxy stackFloatValue: 1.	(interpreterProxy failed) ifTrue:[^nil].	result := self cCode: '__ieee754_ldexp(rcvr, arg)' inSmalltalk: [rcvr timesTwoPower: arg].	(self isnan: result) ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: interpreterProxy methodArgumentCount + 1.	interpreterProxy pushFloat: result.! !!Interpreter methodsFor: 'processes' stamp: 'ikp 4/14/2006 16:30' prior: 23481280!forceInterruptCheck	"force an interrupt check ASAP"	interruptCheckCounter := -1000.	nextPollTick := 0! !SocketPlugin removeSelector: #primitiveSocketSetReusable:!"VMMaker"!----SNAPSHOT----#(13 November 2006 11:14:34 am) Homebase.image priorSource: 288!Object subclass: #MCDefinition	instanceVariableNames: ''	classVariableNames: 'Instances!self clearInstances!----SNAPSHOT----#(13 November 2006 11:15:10 am) Homebase.image priorSource: 27258!----STARTUP----#(16 November 2006 3:57:10 pm) as C:\CroquetSDK-1.0\Homebase.image!!ByteArray methodsFor: '*FFI' stamp: 'ar 11/16/2006 15:35'!isNull	"Answer false since only external addresses can be null"	^false! !!ExternalAddress methodsFor: 'testing' stamp: 'ar 11/16/2006 15:35'!isNull	"Answer true if I am a null pointer"	1 to: self size do:[:i| (self at: i) = 0 ifFalse:[^false]].	^true! !!ExternalObject methodsFor: 'testing' stamp: 'ar 11/16/2006 15:36'!isNull	"Answer true if the receiver currently is a NULL pointer"	^handle == nil or:[handle isNull]! !"FFI"!!MCPackageLoader methodsFor: 'private' stamp: 'ar 11/13/2006 11:30' prior: 25114618!basicLoad	| sz |	errorDefinitions := OrderedCollection new.	[[additions do: [:ea | self tryToLoad: ea] displayingProgress: 'Loading...'.	removals do: [:ea | ea unload] displayingProgress: 'Cleaning up...'.	self shouldWarnAboutErrors ifTrue: [self warnAboutErrors].	[sz := errorDefinitions size.	errorDefinitions do: [:ea | self tryToLoad: ea] 		displayingProgress: 'Reloading...'.	sz = errorDefinitions size] whileFalse. "repeat as long as we make progress"	additions do: [:ea | ea postloadOver: (self obsoletionFor: ea)] displayingProgress: 'Initializing...']		on: InMidstOfFileinNotification 		do: [:n | n resume: true]]			ensure: [self flushChangesFile]! !"Monticello"!!LinedTTCFont class methodsFor: 'as yet unclassified' stamp: 'ar 11/14/2006 15:18' prior: 24584398!fromTTCFont: aTTCFont emphasis: code	| inst |	inst := self new.	inst ttcDescription: aTTCFont ttcDescription.	inst pointSize: aTTCFont pointSize.	inst emphasis: (aTTCFont emphasis bitOr: code).	inst lineGlyph: (aTTCFont ttcDescription at: $_).	^ inst.! !!TTCFont commentStamp: 'nk 4/2/2004 11:32' prior: 33565780!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- Nominal Em size in points. Conversion to pixel sizes depends on the definition of TextStyle class>>pixelsPerInch. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray of <Color -> <Array(256) of glyph>> derivatives		Array -- stores the fonts in the same family but different emphasis.!!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:48' prior: 33566656!initialize"	self initialize"	| tt |	self allSubInstancesDo:[:fnt| fnt flushCache].	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'other' stamp: 'ar 11/14/2006 15:19' prior: 51012377!recreateCache"	self recreateCache."	self allSubInstances do: [:inst | inst flushCache].	Smalltalk garbageCollect.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:28' prior: 33567128!shutDown	"Flush the glyph cache"	GlyphCacheData atAllPut: nil.	GlyphCacheIndex := 0.	ShutdownList ifNotNil:[ShutdownList do:[:fnt| fnt flushCache]].	ShutdownList := WeakSet new.! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:35' prior: 50994402!ascent	ascent ifNil:[ascent := ttcDescription ascender * self pixelSize // (ttcDescription ascender - ttcDescription descender) * Scale y].	^ (fallbackFont notNil			and: [fallbackFont ascent > ascent])		ifTrue: [fallbackFont ascent]		ifFalse: [ascent]! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:19' prior: 33567295!at: char put: form	| assoc |	assoc := foregroundColor -> form.	GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: assoc.	cache at: (char asInteger + 1) put: assoc.! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19' prior: 33567633!cache	^cache! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:43' prior: 50994949!descent	"One is added to make sure the gap between lines is filled.  If we don't add, multi line selection in a text pane look ugly."	^descent ifNil:[descent := (ttcDescription descender * self pixelSize // (ttcDescription descender - ttcDescription ascender)) * Scale y + 1].! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:40' prior: 51000889!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| form glyphInfo destX destY hereX nextX actualFont |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form := glyphInfo at: 1.		hereX := glyphInfo at: 2.		nextX := glyphInfo at: 3.		(actualFont := glyphInfo at: 5) ==  aBitBlt lastFont			ifFalse: [actualFont installOn: aBitBlt].		destY := baselineY - (glyphInfo at: 4). 		aBitBlt sourceForm: form.		aBitBlt destX: destX.		aBitBlt destY: destY.		aBitBlt sourceX: hereX; sourceY: 0.		aBitBlt width: nextX - hereX.		aBitBlt height: form height.		aBitBlt copyBits.		destX := destX + (nextX - hereX) + kernDelta.	].	^ destX @ destY! !!TTCFont methodsFor: 'initialize' stamp: 'ar 11/14/2006 15:17' prior: 33567864!flushCache	"Flush the cache of this font"	cache := foregroundColor := colorToCacheMap := nil.! !!TTCFont methodsFor: 'initialize' stamp: 'ar 11/14/2006 15:27'!foregroundColor: fgColor	"Install the given foreground color"	foregroundColor = fgColor ifFalse:[		foregroundColor := fgColor.		colorToCacheMap ifNil:[colorToCacheMap := Dictionary new].		cache := colorToCacheMap at: fgColor ifAbsentPut:[WeakArray new: 256].		ShutdownList ifNotNil:[ShutdownList add: self].	].! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 16:03' prior: 51006238!formOf: char	| code form |	char charCode > 255		ifTrue: [^ self fallbackFont formOf: char].	cache ifNil:[self foregroundColor: Color black]. "make sure we have a cache"	code := char charCode.	form := cache at: (code + 1).	form class == Association ifTrue:[^self computeForm: code]. "in midst of loading"	form ifNil:[		form := self computeForm: code.		cache at: code+1 put: form.		GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: form.	].	^form! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:43' prior: 51006612!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: ascent "(self ascentOf: aCharacter)";		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:44' prior: 50996901!height	"Answer my height in pixels. This will answer a Float."	^height ifNil:[height := self pixelSize * Scale y]! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:26' prior: 51002112!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	self foregroundColor: fgColor. "install color"	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19' prior: 51003098!ttcDescription: aTTCDescription	ttcDescription := aTTCDescription.	self flushCache.! !!TTCFont methodsFor: 'public' stamp: 'ar 11/14/2006 15:23' prior: 51004251!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	aCharacter charCode > 255 ifTrue: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	^(self formOf: aCharacter) width! !TTCFont removeSelector: #recreateCache!MultiTTCFont removeSelector: #flushCache!"Multilingual"!----SNAPSHOT----#(16 November 2006 4:15:03 pm) Homebase.image priorSource: 27454!----STARTUP----#(26 November 2006 4:46:15 pm) as C:\CroquetSDK-1.0\Homebase.image!World extent!World extent!World extent!World extent!World extent!World extent!----QUIT----#(26 November 2006 4:49:24 pm) Homebase.image priorSource: 35861!